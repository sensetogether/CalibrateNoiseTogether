/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.example.colibris.ui;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;

import android.os.Bundle;
import android.os.Environment;
import android.support.v7.app.AppCompatActivity;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.example.colibris.configuration.Me;
import com.example.colibris.R;
import com.example.colibris.configuration.Configuration;
import com.example.colibris.calib.FileManager;
import com.example.colibris.multi.hypergraph.HyperConnection;
import com.example.colibris.multi.Calibration;

import java.io.File;

/**
 * The InitActivity class refers to an activity used to display information about the device and to reset the calibration app
 */
public class InitActivity extends AppCompatActivity  {
    /**
     * text view
     */
    TextView textView;

    /**
     * local dvice
     */
    private Me me ;
    /*Option Values related to the Configuration file of the App*/

    /**
     *
     */
    private void configure(){


    }

    /**
     * activity creation
     * @param savedInstanceState instance state
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_init);
        // set a text view to display the configuration information
        textView = new TextView(this);
        textView.setTextSize(14);
        textView.setMovementMethod(ScrollingMovementMethod.getInstance());
        ViewGroup layout = findViewById(R.id.content_init_message);
        layout.addView(textView);
        Log.e("Init", "create me");
        me = new Me(this);

        Log.e("Init", "end configure");
        displayInitInfo(); // display informations
    }


    /**
     * diplay some configuration information to the end user
     */
    public void displayInitInfo(){
        configure();


        Calibration multiHopCalibration = me.getMultiHopCalibration();

        /*
         apply the parameters
         */

        if(multiHopCalibration.slope ==1 && multiHopCalibration.intercept == 0 && multiHopCalibration.cumulated_errror ==0){
            textView.setText("Device " + me.localDevice.getVertexId() + " is not calibrated");
            Configuration.IS_CALIBRATED = false;
        }else{
            Calibration singleHopCalibration = me.getSingleHopCalibration();
            Configuration.IS_CALIBRATED = true;
            Configuration.SLOPE = singleHopCalibration.slope;
            Configuration.INTERCEPT = singleHopCalibration.intercept;
            Configuration.CUMULATED_ERRORS = multiHopCalibration.cumulated_errror;
            Configuration.WEIGHTED_CUMULATED_ERROR = multiHopCalibration.weighted_cumulated_error;
            textView.append("Calibration fonction:  \n");
            textView.append("  intercept: " + Configuration.INTERCEPT);
            textView.append(" slope: " + Configuration.SLOPE);
            textView.append(" error: " + Configuration.CUMULATED_ERRORS + "\n");
        }










        textView.append(Configuration.VERTEXNB + " nodes and " + Configuration.REFERENCENB +  " references\n");
        // display the directory that contains all the files that have been generated by the application
        // Get the directory for the user's public pictures directory.
        File file = new File(Environment.getExternalStorageDirectory() + "/Documents");
        boolean isPresent = true;
        if (!file.exists()) {
            isPresent = file.mkdir();
        }
        File[] files = file.listFiles();

        Log.e("init", "set connexion graph");
        me.setConnectionHyperGraph();
        Log.e("init", "set connexion graph");
        textView.append( me.getLocalconnectionGraph() + "\n" );

//    Calibration calibration = me.getCalibration();
        //  Log.e(TAG, "BEST CALIBRATION" + calibration);
    }



//////////////////////////


    /**
     * click on the reset button
     * @param view view
     */
    public void init_Message(View view) {
        configure();
        File file = new File(Environment.getExternalStorageDirectory() + "/Documents");
        //  File file = new File(Environment.getExternalStoragePublicDirectory(
        //        Environment.DIRECTORY_DOCUMENTS).toString());
//        File file = getFilesDir();

        File[] files = file.listFiles();
        for (int i = 0; i < files.length; i++)
        {
            files[i].delete();
        }


        Configuration.MANUAL_SLOPE = 1;
        Configuration.MANUAL_INTERCEPT = 0;
        Configuration.IS_CALIBRATED = false;
        Configuration.WEIGHTED_CUMULATED_ERROR = 0;// these parameters are entered manually
        Configuration.CUMULATED_ERRORS  = 0;// these parameters are entered manually
        Configuration.MANUAL_MEAN_RESIDUAL = 0;// these parameters are entered manually
        Configuration.MANUAL_STD_RESIUDAL = 0;// these parameters are entered manually
        Configuration.MANUAL_R_SQUARED = 1;// these parameters are entered manually
        Configuration.MANUAL_SUM_RESIDUAL   =0 ;// these parameters are entered manually
        Configuration.SHOULD_SIMPLY_CALIBRATE = false;
        Configuration.SHOULD_ROBUSTLY_CALIBRATE = false;
        Configuration.SHOULD_BE_SAVED = false;

        displayInitInfo();
    }




    /**
     * click on a button so as to generate a random hypergraph
     * @param view
     */
    public void random_Message(View view) {
        configure();//extract configuration parameters
        // Generate an empty hypergraph
        HyperConnection hyperConnection = new HyperConnection();
        hyperConnection.getFromFile(this);

        // Log.d("Init activity" , "Create a random hypergraph with " + this.numberOfLinks + " hyperedges of size " + this.meetingSize);
        //populate the hypergraph with random hyperedges
        // hyperConnection.populateWithRandomHyperEdges(this.numberOfLinks, this.meetingSize);

        Me me = new Me(this);

        hyperConnection.spanning2ref( 100, 3, me.localDevice.getVertexId());

        hyperConnection.toFile(this);
        displayInitInfo();
    }



    /**
     * click ona button to genered a connex hypergraph graph
     * @param view view
     */
    public void connex_Message(View view) {
        configure();//extract configuration parameters
        // Generate an empty hypergraph
        HyperConnection hyperConnection = new HyperConnection();
        hyperConnection.getFromFile(this);
        hyperConnection.connectSource2ConsolidateNode(me.localDevice.getVertexId() );
        hyperConnection.toFile(this);
        displayInitInfo();

    }

    /**
     * click on a button to generate a hypergraph that is no connex
     * @param view view
     */
    public void not_connex_Message(View view) {

        configure();//extract configuration parameters
        // Generate an empty hypergraph
        HyperConnection hyperConnection = new HyperConnection();
        hyperConnection.getFromFile(this);
        //populate the hypergraph with some edges connecting the device to r (i.e., the consolidated ndoe
        hyperConnection.almost_connectSource2ConsolidateNode(me.localDevice.getVertexId());
        hyperConnection.toFile(this);
        displayInitInfo();
    }

    /**
     * click on a button to get calibration-related parameters
     * @param view
     */
    public void calibration_Message(View view){
        // extract the hypergraph from the file where it is stored



  //          FileManager file4result = new FileManager("resultat.txt", true, this);
            // Generate an empty hypergraph
            HyperConnection hyperConnection = new HyperConnection();
            hyperConnection.getFromFile(this);
            //populate the hypergraph with random hyperedges
            Me me = new Me(this);

//            int hyperedgeCard = 3;
 //           int hyperedgeNB = 10;// 5 10 15 20

  //          hyperConnection.spanning2ref(hyperedgeNB, hyperedgeCard, me.localDevice.getVertexId());
   //         hyperConnection.toFile(this);

            //compute shortest path from the local device
     //       long before = System.currentTimeMillis();
       //     HyperConnection bestHyperConnexion = me.getShortestPath(me.localDevice.getVertexId());
           // long after = System.currentTimeMillis();


         //   textView.append( "\n Best Shortest path: \n");
          //  textView.append(         bestHyperConnexion.toString());

        Calibration multiHopCalibration = me.getMultiHopCalibration();

        /*
         apply the parameters
         */

        if(multiHopCalibration.slope ==1 && multiHopCalibration.intercept == 0 && multiHopCalibration.cumulated_errror ==0){
            textView.setText("Device " + me.localDevice.getVertexId() + " is not calibrated");
            Configuration.IS_CALIBRATED = false;
        }else{
            Calibration singleHopCalibration = me.getSingleHopCalibration();
            Configuration.IS_CALIBRATED = true;
            Configuration.SLOPE = singleHopCalibration.slope;
            Configuration.INTERCEPT = singleHopCalibration.intercept;
            Configuration.CUMULATED_ERRORS = multiHopCalibration.cumulated_errror;
            Configuration.WEIGHTED_CUMULATED_ERROR = multiHopCalibration.weighted_cumulated_error;
            textView.append("Calibration fonction:  \n");
            textView.append("  intercept: " + Configuration.INTERCEPT);
            textView.append(" slope: " + Configuration.SLOPE);
            textView.append(" error: " + Configuration.CUMULATED_ERRORS + "\n");
        }



    }


    /**
     * click on a button to get the best calibration path
     * @param view
     */
    public void shortest_Message(View view){
        // extract the hypergraph from the file where it is stored
        HyperConnection hyperConnection = new HyperConnection();
        hyperConnection.getFromFile(this);

        //compute shortest path from the local device

        long before = System.currentTimeMillis();
        HyperConnection bestHyperConnexion = me.getShortestPath(me.localDevice.getVertexId() );
        //long after = System.currentTimeMillis();

        textView.append( "\n Best Shortest path: \n");
        textView.append(         bestHyperConnexion.toString());


        // textView.append("time in ms to compute shortest path" + (after-before));
       // Log.e("init", "time in ms to compute shortest path" + (after-before));



    }
}
